<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>SnakeBet</title>
  <style>
    :root {
      --bg-dark: #05060a;
      --accent: #1ee97b;
      --accent-soft: rgba(30, 233, 123, 0.18);
      --text-main: #f5f5f5;
      --text-muted: #a4a9b5;
    }

    * {
      box-sizing: border-box;
    }

    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }

    /* ---------- Start screen layout ---------- */
    body.start-screen {
      display: flex;
      align-items: flex-start;
      justify-content: center;
      padding-top: 8vh;
      background:
        radial-gradient(circle at top, #222642 0, #05060a 45%, #020308 100%);
      color: var(--text-main);
    }

    #start-screen {
      max-width: 520px;
      width: min(520px, 92vw);
      padding: 32px 40px 36px;
      background: rgba(5, 7, 16, 0.94);
      border-radius: 24px;
      border: 1px solid rgba(255, 255, 255, 0.06);
      box-shadow:
        0 30px 80px rgba(0, 0, 0, 0.85),
        0 0 0 1px rgba(255, 255, 255, 0.02);
      backdrop-filter: blur(18px);
      animation: pop-in 420ms cubic-bezier(.16,.84,.44,1);
      position: relative;
    }

    #start-screen h1 {
      margin: 0 0 6px;
      font-size: 44px;
      letter-spacing: 0.05em;
      text-transform: uppercase;
    }

    .tagline {
      margin: 0 0 28px;
      font-size: 15px;
      color: var(--text-muted);
    }

    .tagline-sub {
      margin: 8px 0 18px;
      font-size: 12px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: #1ee97b;
      text-shadow: 0 0 8px rgba(30, 233, 123, 0.35);
    }

    .field-group {
      margin-top: 6px;
    }

    .field-label {
      display: block;
      font-size: 14px;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: var(--text-muted);
      margin-bottom: 6px;
    }

    .input-row {
      display: flex;
      align-items: center;
      gap: 12px;
    }

    #username {
      flex: 1;
      padding: 10px 22px;
      font-size: 18px;
      border-radius: 999px;
      border: 2px solid rgba(255, 255, 255, 0.22);
      background: #05060d;
      color: var(--text-main);
      outline: none;
      transition: border-color 160ms ease, box-shadow 160ms ease, background 160ms ease;
    }

    #username::placeholder {
      color: rgba(255, 255, 255, 0.35);
    }

    #username:focus {
      border-color: var(--accent);
      box-shadow: 0 0 0 3px var(--accent-soft);
      background: #050816;
    }
	
	#server-choice {
  width: 100%;
  padding: 10px 22px;
  font-size: 18px;
  border-radius: 999px;
  border: 2px solid rgba(255, 255, 255, 0.22);
  background: #05060d;
  color: var(--text-main);
  outline: none;
  transition: border-color 160ms ease, box-shadow 160ms ease, background 160ms ease;
  appearance: none;
  background-image: linear-gradient(to bottom, #05060d, #040509);
}

#server-choice:focus {
  border-color: var(--accent);
  box-shadow: 0 0 0 3px var(--accent-soft);
  background: #050816;
}

#server-meta {
  margin-top: 10px;
  font-size: 13px;
  color: var(--text-muted);
  text-align: center;
}
#server-player-count {
  color: var(--accent);
  font-weight: 700;
  text-shadow: 0 0 8px rgba(30, 233, 123, 0.25);
}



    #bet-amount {
      width: 100%;
      padding: 10px 22px;
      font-size: 18px;
      border-radius: 999px;
      border: 2px solid rgba(255, 255, 255, 0.22);
      background: #05060d;
      color: var(--text-main);
      outline: none;
      transition: border-color 160ms ease, box-shadow 160ms ease, background 160ms ease;
      appearance: none;
      background-image: linear-gradient(to bottom, #05060d, #040509);
    }

    #bet-amount:focus {
      border-color: var(--accent);
      box-shadow: 0 0 0 3px var(--accent-soft);
      background: #050816;
    }

    #start-btn {
      margin-top: 26px;
      width: 100%;
      padding: 12px 26px;
      font-size: 18px;
      font-weight: 600;
      border-radius: 999px;
      border: none;
      cursor: pointer;
      color: #020304;
      background-image: linear-gradient(135deg, #28ff9f, #11d46b);
      box-shadow: 0 14px 30px rgba(0, 0, 0, 0.75);
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      transform: translateY(0);
      transition: transform 130ms ease, box-shadow 130ms ease, filter 130ms ease;
    }

    #start-btn span {
      text-transform: uppercase;
      letter-spacing: 0.16em;
      font-size: 14px;
    }

    #start-btn:hover {
      transform: translateY(-1px);
      box-shadow: 0 18px 40px rgba(0, 0, 0, 0.9);
      filter: brightness(1.04);
    }

    #start-btn:active {
      transform: translateY(1px);
      box-shadow: 0 10px 24px rgba(0, 0, 0, 0.85);
      filter: brightness(0.96);
    }

    #snakebet-logo {
      position: absolute;
      top: 30px;
      right: 20px;
      width: 160px;
      height: 160px;
      object-fit: contain;
      filter: drop-shadow(0 0 12px rgba(30, 233, 123, 0.35)) brightness(1.05);
      user-select: none;
      pointer-events: none;
    }

    .hint {
      margin-top: 10px;
      font-size: 13px;
      color: var(--text-muted);
      text-align: center;
    }

    .footer-text {
      margin-top: 18px;
      font-size: 12px;
      text-align: center;
      color: #6a7284;
    }

    /* ---------- Game canvas layout ---------- */
    body.playing {
      margin: 0;
      background: #000;
      display: block;
    }

    body.playing #start-screen {
      display: none;
    }

    #game {
      position: fixed;
      inset: 0;
      display: none;
    }

    body.playing #game {
      display: block;
    }

    @keyframes pop-in {
      from {
        opacity: 0;
        transform: translateY(12px) scale(0.97);
      }
      to {
        opacity: 1;
        transform: translateY(0) scale(1);
      }
    }

    @media (max-width: 480px) {
      #start-screen {
        padding: 24px 20px 28px;
        border-radius: 18px;
      }
      #start-screen h1 {
        font-size: 32px;
      }
    }
  </style>
</head>

<body class="start-screen">
  <!-- START SCREEN -->
  <div id="start-screen">
    <img id="snakebet-logo"
         src="81af9b43-3439-4c84-83af-bf4e95822a25.png"
         alt="SnakeBet Logo" />

    <h1>SnakeBet</h1>
    <p class="tagline-sub">The first <b>BIG</b> skill-based winnings site!</p>
    <p class="tagline">Claim your name and slither into the arena.</p>

    <!-- Username -->
    <div class="field-group">
      <span class="field-label">Username</span>
      <div class="input-row">
        <input
          id="username"
          type="text"
          maxlength="16"
          autocomplete="off"
          placeholder="e.g. CoilKing"
        />
      </div>
    </div>

    <!-- Server -->
    <div class="field-group" style="margin-top: 20px;">
      <span class="field-label">Select Server</span>

      <select id="server-choice">
        <option value="wss://snakebet-server.fly.dev">SnakeBet Global</option>
      </select>

      <div id="server-meta">
        Players online: <span id="server-player-count">—</span>
      </div>
    </div>

    <!-- Bet Amount -->
    <div class="field-group" style="margin-top: 20px;">
      <span class="field-label">Select Bet Amount</span>
      <select id="bet-amount">
        <option value="1">1$</option>
        <option value="5">5$</option>
        <option value="10">10$</option>
        <option value="20">20$</option>
        <option value="50">50$</option>
        <option value="100">100$</option>
      </select>
    </div>

    <button id="start-btn"><span>Play</span></button>

    <p class="hint">Press <b>Enter</b> in the box to start</p>
    <p class="footer-text">Use your mouse to steer. Left click to boost.</p>
  </div>

  <!-- GAME CANVAS -->
  <canvas id="game"></canvas>

  <script>
    // ================== PRE-GAME / SHARED CONSTANTS ==================
    let username = "Player";
    let betAmount = 1;

    const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d");
	
	const serverChoiceEl = document.getElementById("server-choice");
	const serverPlayerCountEl = document.getElementById("server-player-count");


    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }
    window.addEventListener("resize", resizeCanvas);

    document.getElementById("start-btn").addEventListener("click", startGame);
    document.getElementById("username").addEventListener("keydown", (e) => {
      if (e.key === "Enter") startGame();
    });

    // World & snake constants (must match server)
    const worldWidth  = 5000;
    const worldHeight = 5000;

    const baseRadius = 14;
    const baseLength = 160;
    const lengthGainPerFood = 35;
    const lengthLossPerSecond = 60;

    const normalSpeed = 260;
    const boostSpeed  = 420;
    const turnRate    = 7;
    const maxDt       = 0.035;

    // Radius helper usable for both local + remote snakes
    function getRadiusForLength(length) {
      const growthRate = 0.25 / 1000;
      const extraLength = Math.max(0, length - baseLength);
      const scale = 1 + extraLength * growthRate;
      return baseRadius * scale;
    }

    // Generic snake trimming
    function trimSnakeArray(points, targetLength) {
      if (!points || points.length < 2) return;

      let distSoFar = 0;
      for (let i = 1; i < points.length; i++) {
        const a = points[i - 1];
        const b = points[i];
        const dx = a.x - b.x;
        const dy = a.y - b.y;
        distSoFar += Math.hypot(dx, dy);
        if (distSoFar > targetLength) {
          points.length = i;
          break;
        }
      }
    }

    // ================== MULTIPLAYER (WEBSOCKET) ==================
    // For local testing:
    // let socket = new WebSocket("ws://localhost:8080");
    // For production, switch to your wss:// endpoint.
    let socket = new WebSocket("wss://snakebet-server.fly.dev");

    let socketOpen = false;
    let myId = null;

    // id -> { id, name, hue, body: [{x,y},...], length, angle, samples, interp }
    const remoteSnakes = {};

    socket.addEventListener("open", () => {
      socketOpen = true;
      console.log("Connected to SnakeBet server");
    });

    socket.addEventListener("close", () => {
	serverPlayerCountEl.textContent = "—";
      console.log("Disconnected from server");
      socketOpen = false;
    });

    socket.addEventListener("error", (err) => {
      console.error("WebSocket error:", err);
    });

    socket.addEventListener("message", (event) => {
      const data = JSON.parse(event.data);

      if (data.type === "welcome") {
        myId = data.id;
        console.log("Welcome, id =", myId);
        return;
      }

      if (data.type === "world") {
		serverPlayerCountEl.textContent = String(data.players.length);
        const seenIds = new Set();
        const now = performance.now();

        for (const p of data.players) {
          if (p.id === myId) continue; // don't track ourselves

          seenIds.add(p.id);

          let s = remoteSnakes[p.id];
          if (!s) {
            s = remoteSnakes[p.id] = {
              id: p.id,
              name: p.name || "Player",
              hue: typeof p.hue === "number" ? p.hue : Math.floor(Math.random() * 360),
              body: [],
              samples: [],
              interp: null,
              length: typeof p.length === "number" ? p.length : baseLength,
              angle: typeof p.angle === "number" ? p.angle : 0
            };
          }

          s.name = p.name || s.name;
          if (typeof p.hue === "number") s.hue = p.hue;

          // Push a new snapshot sample
          s.samples.push({
            time: now,
            x: p.x,
            y: p.y,
            angle: typeof p.angle === "number" ? p.angle : s.angle,
            length: typeof p.length === "number" ? p.length : s.length
          });

          // Update last known angle/length for fallback
          if (typeof p.angle === "number") s.angle = p.angle;
          if (typeof p.length === "number") s.length = p.length;

          // Limit history size
          if (s.samples.length > 60) {
            s.samples.shift();
          }
        }

        // Remove snakes not present in this snapshot
        for (const id in remoteSnakes) {
          if (!seenIds.has(id)) {
            delete remoteSnakes[id];
          }
        }

        return;
      }
    });

    function sendJoin() {
      if (!socketOpen) return;
      socket.send(JSON.stringify({
        type: "join",
        name: username,
        hue: snakeHue
      }));
    }

    function sendState(headX, headY, angle, length) {
      if (!socketOpen) return;
      socket.send(JSON.stringify({
        type: "state",
        x: headX,
        y: headY,
        angle,
        length
      }));
    }

    // ================== SNAKE GAME STATE ==================

    let snakeHue = Math.floor(Math.random() * 360);
    let snakeLength = baseLength;

    let snake = [];
    let foods = [];

    let mouse = { x: 0, y: 0 };
    let boosting = false;
    let lastAngle = 0;
    let lastTime  = null;

    let camX = 0;
    let camY = 0;

    // ---- Zoom settings ----
    let zoom = 1;
    const minZoom = 0.6;
    const maxZoom = 2.0;

    function getCurrentRadius() {
      return getRadiusForLength(snakeLength);
    }

    // ================== START GAME ==================
    let hasStarted = false;

    function startGame() {
      if (hasStarted) return;
      hasStarted = true;

      const input = document.getElementById("username");
      const name = input.value.trim();
      if (name !== "") username = name;

      const betSelect = document.getElementById("bet-amount");
      betAmount = parseInt(betSelect.value, 10) || 1;

      document.body.classList.remove("start-screen");
      document.body.classList.add("playing");

      resizeCanvas();
      respawn();
      resetFood();
      lastTime = null;

      if (socketOpen) {
        sendJoin();
      } else {
        const joinOnOpen = () => {
          socket.removeEventListener("open", joinOnOpen);
          sendJoin();
        };
        socket.addEventListener("open", joinOnOpen);
      }

      requestAnimationFrame(gameLoop);
    }

    // ================== INIT / RESPAWN / FOOD ==================
    function respawn() {
      const x = worldWidth / 2;
      const y = worldHeight / 2;

      snake = [{ x, y }];
      snakeLength = baseLength;
      boosting = false;
      lastAngle = 0;
      lastTime  = null;

      camX = x;
      camY = y;

      mouse.x = canvas.width / 2;
      mouse.y = canvas.height / 2;

      // don’t re-randomize snakeHue here; keep same color for this session
    }

    function resetFood() {
      foods = [];
      for (let i = 0; i < 200; i++) spawnFood();
    }

    function spawnFood() {
      foods.push({
        x: Math.random() * worldWidth,
        y: Math.random() * worldHeight,
        radius: 4 + Math.random() * 3,
        color: `hsl(${Math.random() * 360}, 90%, 60%)`
      });
    }

    // ================== INPUT ==================
    canvas.addEventListener("mousemove", (e) => {
      const rect = canvas.getBoundingClientRect();
      mouse.x = e.clientX - rect.left;
      mouse.y = e.clientY - rect.top;
    });

    canvas.addEventListener("mousedown", (e) => {
      if (e.button === 0) boosting = true;
    });

    canvas.addEventListener("mouseup", (e) => {
      if (e.button === 0) boosting = false;
    });

    canvas.addEventListener("mouseleave", () => {
      boosting = false;
    });

    canvas.addEventListener(
      "wheel",
      (e) => {
        e.preventDefault();
        const factor = 1.08;

        if (e.deltaY < 0) zoom *= factor;
        else zoom /= factor;

        if (zoom < minZoom) zoom = minZoom;
        if (zoom > maxZoom) zoom = maxZoom;
      },
      { passive: false }
    );

    // ================== UTILS ==================
    function shortestAngleDiff(a, b) {
      let diff = (b - a) % (Math.PI * 2);
      if (diff > Math.PI) diff -= Math.PI * 2;
      if (diff < -Math.PI) diff += Math.PI * 2;
      return diff;
    }

    const INTERP_DELAY_MS = 100;

    function updateRemoteSnakes(dt) {
      const now = performance.now();
      const renderTime = now - INTERP_DELAY_MS;

      for (const id in remoteSnakes) {
        const s = remoteSnakes[id];
        const arr = s.samples;
        if (!arr || arr.length === 0) continue;

        // Keep only the two samples bracketing renderTime
        while (arr.length >= 2 && arr[1].time <= renderTime) {
          arr.shift();
        }

        const a = arr[0];
        const b = arr[1] || arr[0];

        let t = 0;
        if (b.time !== a.time) {
          t = (renderTime - a.time) / (b.time - a.time);
          if (t < 0) t = 0;
          if (t > 1) t = 1;
        }

        const x = a.x + (b.x - a.x) * t;
        const y = a.y + (b.y - a.y) * t;

        const baseAngle = a.angle;
        let diff = shortestAngleDiff(baseAngle, b.angle);
        const angle = baseAngle + diff * t;

        const length = a.length + (b.length - a.length) * t;

        s.interp = { x, y, angle, length };

        if (!s.body || s.body.length === 0) {
          s.body = [{ x, y }];
        } else {
          const head = s.body[0];
          const dx = x - head.x;
          const dy = y - head.y;
          const dist = Math.hypot(dx, dy);
          const minStep = 1;

          if (dist > minStep) {
            s.body.unshift({ x, y });
          } else {
            head.x = x;
            head.y = y;
          }
        }

        trimSnakeArray(s.body, length);
      }
    }

    function worldToScreen(wx, wy) {
      return {
        x: (wx - camX) * zoom + canvas.width / 2,
        y: (wy - camY) * zoom + canvas.height / 2
      };
    }

    // ================== MAIN LOOP ==================
    function gameLoop(timestamp) {
      if (!lastTime) lastTime = timestamp;
      let dt = (timestamp - lastTime) / 1000;
      lastTime = timestamp;

      if (dt > maxDt) dt = maxDt;

      update(dt);
      draw();

      requestAnimationFrame(gameLoop);
    }

    // ================== UPDATE ==================
    function update(dt) {
      if (!snake.length) return;
      const head = snake[0];

      camX = head.x;
      camY = head.y;

      const centerX = canvas.width / 2;
      const centerY = canvas.height / 2;

      const mx = mouse.x - centerX;
      const my = mouse.y - centerY;
      const distMouse = Math.hypot(mx, my);

      const aimDeadZone = 6;
      let targetAngle = lastAngle;
      if (distMouse > aimDeadZone) {
        targetAngle = Math.atan2(my, mx);
      }

      const diff = shortestAngleDiff(lastAngle, targetAngle);
      const maxTurn = turnRate * dt;
      if (Math.abs(diff) <= maxTurn) {
        lastAngle = targetAngle;
      } else {
        lastAngle += Math.sign(diff) * maxTurn;
      }

      let speed = normalSpeed;
      const canBoost = snakeLength > baseLength + 1;

      if (boosting && canBoost) {
        speed = boostSpeed;
        snakeLength -= lengthLossPerSecond * dt;
        if (snakeLength < baseLength) snakeLength = baseLength;
      } else {
        speed = normalSpeed;
      }

      const stepX = Math.cos(lastAngle) * speed * dt;
      const stepY = Math.sin(lastAngle) * speed * dt;

      const newHead = {
        x: head.x + stepX,
        y: head.y + stepY
      };

      // local border + self-death (for responsiveness)
      if (
        newHead.x < 0 || newHead.x > worldWidth ||
        newHead.y < 0 || newHead.y > worldHeight
      ) {
        respawn();
        return;
      }

      snake.unshift(newHead);
      trimSnakeArray(snake, snakeLength);

      const currentRadius = getCurrentRadius();
      const headRadiusWorld = currentRadius * 1.2;
      const killRadius = headRadiusWorld * 0.75;
      const selfHitStartIndex = 12;

      for (let i = selfHitStartIndex; i < snake.length; i++) {
        const s = snake[i];
        const dx = s.x - newHead.x;
        const dy = s.y - newHead.y;
        if (Math.hypot(dx, dy) < killRadius) {
          respawn();
          return;
        }
      }

      for (let i = foods.length - 1; i >= 0; i--) {
        const f = foods[i];
        const dx = f.x - newHead.x;
        const dy = f.y - newHead.y;
        if (Math.hypot(dx, dy) < headRadiusWorld + f.radius) {
          foods.splice(i, 1);
          snakeLength += lengthGainPerFood;
          spawnFood();
        }
      }

      // send my state to the server
      sendState(newHead.x, newHead.y, lastAngle, snakeLength);

      // smooth remote snakes based on snapshot history
      updateRemoteSnakes(dt);
    }

    // ================== DRAWING ==================
    function drawBackground() {
      const centerX = canvas.width / 2;
      const centerY = canvas.height / 2;

      const grd = ctx.createRadialGradient(
        centerX, centerY, 40,
        centerX, centerY, Math.max(canvas.width, canvas.height)
      );

      const actuallyBoosting = boosting && snakeLength > baseLength + 1;
      const innerColor = actuallyBoosting ? "#333333" : "#222222";

      grd.addColorStop(0, innerColor);
      grd.addColorStop(1, "#050505");

      ctx.fillStyle = grd;
      ctx.fillRect(0, 0, canvas.width, canvas.height);
    }

    function drawWorldBorder() {
      const topLeft = worldToScreen(0, 0);
      const w = worldWidth * zoom;
      const h = worldHeight * zoom;

      ctx.save();
      ctx.lineWidth = 4;
      ctx.strokeStyle = "red";
      ctx.strokeRect(topLeft.x, topLeft.y, w, h);
      ctx.restore();
    }

    function drawFood() {
      for (const f of foods) {
        const p = worldToScreen(f.x, f.y);
        if (p.x < -40 || p.x > canvas.width + 40 || p.y < -40 || p.y > canvas.height + 40) continue;

        ctx.beginPath();
        ctx.arc(p.x, p.y, f.radius * zoom, 0, Math.PI * 2);
        ctx.fillStyle = f.color;
        ctx.fill();
      }
    }

    function drawSnakeBodyGeneric(body, length, hue) {
      if (!body || body.length < 2) return;

      const currentRadius = getRadiusForLength(length);
      const tailIndex = body.length - 1;
      const tail = body[tailIndex];
      const head = body[0];

      const tailScr = worldToScreen(tail.x, tail.y);
      const headScr = worldToScreen(head.x, head.y);

      ctx.save();
      ctx.lineJoin = "round";
      ctx.lineCap = "round";
      ctx.beginPath();
      ctx.moveTo(tailScr.x, tailScr.y);
      for (let i = tailIndex - 1; i >= 0; i--) {
        const p = worldToScreen(body[i].x, body[i].y);
        ctx.lineTo(p.x, p.y);
      }

      ctx.lineWidth = currentRadius * 2 * zoom;

      const gradient = ctx.createLinearGradient(tailScr.x, tailScr.y, headScr.x, headScr.y);
      gradient.addColorStop(0, `hsl(${hue}, 75%, 35%)`);
      gradient.addColorStop(1, `hsl(${hue}, 85%, 60%)`);
      ctx.strokeStyle = gradient;
      ctx.stroke();
      ctx.restore();
    }

    function drawSnakeHeadAndEyesGeneric(head, length, hue, angle) {
      const currentRadius = getRadiusForLength(length);

      const headRadiusWorld = currentRadius * 1.2;
      const eyeForward = headRadiusWorld * 0.4;
      const eyeSide    = headRadiusWorld * 0.55;
      const eyeRadiusWorld  = headRadiusWorld * 0.38;
      const pupilRadiusWorld = eyeRadiusWorld * 0.5;

      const h = worldToScreen(head.x, head.y);

      ctx.beginPath();
      ctx.arc(h.x, h.y, headRadiusWorld * zoom, 0, Math.PI * 2);
      ctx.fillStyle = `hsl(${hue}, 85%, 65%)`;
      ctx.fill();
      ctx.lineWidth = 3 * zoom;
      ctx.strokeStyle = "#000";
      ctx.stroke();

      for (const side of [-1, 1]) {
        const exWorld =
          head.x +
          Math.cos(angle) * eyeForward +
          Math.cos(angle + side * Math.PI / 2) * eyeSide * 0.6;

        const eyWorld =
          head.y +
          Math.sin(angle) * eyeForward +
          Math.sin(angle + side * Math.PI / 2) * eyeSide * 0.6;

        const e = worldToScreen(exWorld, eyWorld);

        ctx.beginPath();
        ctx.arc(e.x, e.y, eyeRadiusWorld * zoom, 0, Math.PI * 2);
        ctx.fillStyle = "#ffffff";
        ctx.fill();
        ctx.lineWidth = 2 * zoom;
        ctx.strokeStyle = "#000000";
        ctx.stroke();

        const pxWorld =
          exWorld + Math.cos(angle) * eyeRadiusWorld * 0.4;
        const pyWorld =
          eyWorld + Math.sin(angle) * eyeRadiusWorld * 0.4;

        const p = worldToScreen(pxWorld, pyWorld);

        ctx.beginPath();
        ctx.arc(p.x, p.y, pupilRadiusWorld * zoom, 0, Math.PI * 2);
        ctx.fillStyle = "#000000";
        ctx.fill();
      }
    }

    function drawMySnake() {
      if (!snake.length) return;
      drawSnakeBodyGeneric(snake, snakeLength, snakeHue);
      const head = snake[0];
      drawSnakeHeadAndEyesGeneric(head, snakeLength, snakeHue, lastAngle);
    }

    function drawRemoteSnakes() {
      for (const id in remoteSnakes) {
        const s = remoteSnakes[id];
        if (!s.body || !s.body.length) continue;

        const interp = s.interp;
        const length = interp ? interp.length : s.length;
        const angle  = interp ? interp.angle  : s.angle;

        drawSnakeBodyGeneric(s.body, length, s.hue);

        const headPos = interp ? { x: interp.x, y: interp.y } : s.body[0];

        drawSnakeHeadAndEyesGeneric(headPos, length, s.hue, angle);

        const headScr = worldToScreen(headPos.x, headPos.y);
        const radius = getRadiusForLength(length) * zoom * 1.4;

        ctx.save();
        ctx.fillStyle = "white";
        ctx.font = "14px Arial";
        ctx.textAlign = "center";
        ctx.fillText(s.name || "Player", headScr.x, headScr.y - radius - 6);
        ctx.restore();
      }
    }

    function drawDirectionIndicator() {
      if (!snake.length) return;
      const head = snake[0];
      const currentRadius = getCurrentRadius();

      const distWorld = currentRadius * 3;
      const sizeWorld = currentRadius * 0.45;

      const dotXWorld = head.x + Math.cos(lastAngle) * distWorld;
      const dotYWorld = head.y + Math.sin(lastAngle) * distWorld;

      const d = worldToScreen(dotXWorld, dotYWorld);

      ctx.beginPath();
      ctx.arc(d.x, d.y, sizeWorld * zoom, 0, Math.PI * 2);
      ctx.lineWidth = 2 * zoom;
      ctx.strokeStyle = "rgba(255,255,255,0.8)";
      ctx.stroke();
    }

    function drawHUD() {
      ctx.fillStyle = "rgba(255,255,255,0.9)";
      ctx.font = "16px Arial";
      ctx.textAlign = "left";
      ctx.fillText(`Player: ${username}`, 20, 30);
      ctx.fillText(`Bet: ${betAmount}$`, 20, 50);
      ctx.fillText("Move the mouse around your snake to steer (Slither-style).", 20, 70);
      ctx.fillText("Hold LEFT MOUSE to BOOST (spends length).", 20, 90);
      ctx.fillText(`Length: ${Math.round(snakeLength)}`, 20, 110);
      ctx.fillText(`Zoom: ${zoom.toFixed(2)}x`, 20, 130);

      if (boosting && snakeLength > baseLength + 1) {
        ctx.fillStyle = "rgba(255,200,200,0.95)";
        ctx.fillText("BOOSTING!", 20, 150);
      }

      ctx.textAlign = "right";
      ctx.fillStyle = "rgba(255,255,255,0.7)";
      ctx.fillText(
        "Mouse wheel = zoom. Red box = world border. Hit border or your body to respawn.",
        canvas.width - 20,
        30
      );
    }

    function draw() {
      drawBackground();
      drawWorldBorder();
      if (!snake || snake.length === 0) return;
      drawFood();
      drawMySnake();
      drawRemoteSnakes();
      drawDirectionIndicator();
      drawHUD();
    }
  </script>
</body>
</html>
