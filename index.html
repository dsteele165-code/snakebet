<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>SnakeBet</title>
  <style>
    :root {
      --bg-dark: #05060a;
      --accent: #1ee97b;
      --accent-soft: rgba(30, 233, 123, 0.18);
      --text-main: #f5f5f5;
      --text-muted: #a4a9b5;
    }

    * {
      box-sizing: border-box;
    }

    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }

    /* ---------- Start screen layout ---------- */
    body.start-screen {
      display: flex;
      align-items: flex-start;
      justify-content: center;
      padding-top: 8vh;
      background:
        radial-gradient(circle at top, #222642 0, #05060a 45%, #020308 100%);
      color: var(--text-main);
    }

    #start-screen {
      max-width: 520px;
      width: min(520px, 92vw);
      padding: 32px 40px 36px;
      background: rgba(5, 7, 16, 0.94);
      border-radius: 24px;
      border: 1px solid rgba(255, 255, 255, 0.06);
      box-shadow:
        0 30px 80px rgba(0, 0, 0, 0.85),
        0 0 0 1px rgba(255, 255, 255, 0.02);
      backdrop-filter: blur(18px);
      animation: pop-in 420ms cubic-bezier(.16,.84,.44,1);
      position: relative;
    }

    #start-screen h1 {
      margin: 0 0 6px;
      font-size: 44px;
      letter-spacing: 0.05em;
      text-transform: uppercase;
    }

    .tagline {
      margin: 0 0 28px;
      font-size: 15px;
      color: var(--text-muted);
    }

    .tagline-sub {
      margin: 8px 0 18px;
      font-size: 12px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: #1ee97b;
      text-shadow: 0 0 8px rgba(30, 233, 123, 0.35);
    }

    .field-group {
      margin-top: 6px;
    }

    .field-label {
      display: block;
      font-size: 14px;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: var(--text-muted);
      margin-bottom: 6px;
    }

    .input-row {
      display: flex;
      align-items: center;
      gap: 12px;
    }

    #username {
      flex: 1;
      padding: 10px 22px;
      font-size: 18px;
      border-radius: 999px;
      border: 2px solid rgba(255, 255, 255, 0.22);
      background: #05060d;
      color: var(--text-main);
      outline: none;
      transition: border-color 160ms ease, box-shadow 160ms ease, background 160ms ease;
    }

    #username::placeholder {
      color: rgba(255, 255, 255, 0.35);
    }

    #username:focus {
      border-color: var(--accent);
      box-shadow: 0 0 0 3px var(--accent-soft);
      background: #050816;
    }

    #server-choice {
      width: 100%;
      padding: 10px 22px;
      font-size: 18px;
      border-radius: 999px;
      border: 2px solid rgba(255, 255, 255, 0.22);
      background: #05060d;
      color: var(--text-main);
      outline: none;
      transition: border-color 160ms ease, box-shadow 160ms ease, background 160ms ease;
      appearance: none;
      background-image: linear-gradient(to bottom, #05060d, #040509);
    }

    #server-choice:focus {
      border-color: var(--accent);
      box-shadow: 0 0 0 3px var(--accent-soft);
      background: #050816;
    }

    #server-meta {
      margin-top: 10px;
      font-size: 13px;
      color: var(--text-muted);
      text-align: center;
    }

    #server-player-count {
      color: var(--accent);
      font-weight: 700;
      text-shadow: 0 0 8px rgba(30, 233, 123, 0.25);
    }

    #bet-amount {
      width: 100%;
      padding: 10px 22px;
      font-size: 18px;
      border-radius: 999px;
      border: 2px solid rgba(255, 255, 255, 0.22);
      background: #05060d;
      color: var(--text-main);
      outline: none;
      transition: border-color 160ms ease, box-shadow 160ms ease, background 160ms ease;
      appearance: none;
      background-image: linear-gradient(to bottom, #05060d, #040509);
    }

    #bet-amount:focus {
      border-color: var(--accent);
      box-shadow: 0 0 0 3px var(--accent-soft);
      background: #050816;
    }

    #start-btn {
      margin-top: 26px;
      width: 100%;
      padding: 12px 26px;
      font-size: 18px;
      font-weight: 600;
      border-radius: 999px;
      border: none;
      cursor: pointer;
      color: #020304;
      background-image: linear-gradient(135deg, #28ff9f, #11d46b);
      box-shadow: 0 14px 30px rgba(0, 0, 0, 0.75);
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      transform: translateY(0);
      transition: transform 130ms ease, box-shadow 130ms ease, filter 130ms ease;
    }

    #start-btn span {
      text-transform: uppercase;
      letter-spacing: 0.16em;
      font-size: 14px;
    }

    #start-btn:hover {
      transform: translateY(-1px);
      box-shadow: 0 18px 40px rgba(0, 0, 0, 0.9);
      filter: brightness(1.04);
    }

    #start-btn:active {
      transform: translateY(1px);
      box-shadow: 0 10px 24px rgba(0, 0, 0, 0.85);
      filter: brightness(0.96);
    }

    #snakebet-logo {
      position: absolute;
      top: 30px;
      right: 20px;
      width: 160px;
      height: 160px;
      object-fit: contain;
      filter: drop-shadow(0 0 12px rgba(30, 233, 123, 0.35)) brightness(1.05);
      user-select: none;
      pointer-events: none;
    }

    .hint {
      margin-top: 10px;
      font-size: 13px;
      color: var(--text-muted);
      text-align: center;
    }

    .footer-text {
      margin-top: 18px;
      font-size: 12px;
      text-align: center;
      color: #6a7284;
    }

    /* ---------- Game canvas layout ---------- */
    body.playing {
      margin: 0;
      background: #000;
      display: block;
    }

    body.playing #start-screen {
      display: none;
    }

    #game {
      position: fixed;
      inset: 0;
      display: none;
    }

    body.playing #game {
      display: block;
    }

    @keyframes pop-in {
      from {
        opacity: 0;
        transform: translateY(12px) scale(0.97);
      }
      to {
        opacity: 1;
        transform: translateY(0) scale(1);
      }
    }

    @media (max-width: 480px) {
      #start-screen {
        padding: 24px 20px 28px;
        border-radius: 18px;
      }
      #start-screen h1 {
        font-size: 32px;
      }
    }
  </style>
</head>

<body class="start-screen">
  <!-- START SCREEN -->
  <div id="start-screen">
    <img id="snakebet-logo"
         src="81af9b43-3439-4c84-83af-bf4e95822a25.png"
         alt="SnakeBet Logo" />

    <h1>SnakeBet</h1>
    <p class="tagline-sub">The first <b>BIG</b> skill-based winnings site!</p>
    <p class="tagline">Claim your name and slither into the arena.</p>

    <!-- Username -->
    <div class="field-group">
      <span class="field-label">Username</span>
      <div class="input-row">
        <input
          id="username"
          type="text"
          maxlength="16"
          autocomplete="off"
          placeholder="e.g. CoilKing"
        />
      </div>
    </div>

    <!-- Server -->
    <div class="field-group" style="margin-top: 20px;">
      <span class="field-label">Select Server</span>

      <select id="server-choice">
        <option value="wss://snakebet-server.fly.dev">SnakeBet Global</option>
      </select>

      <div id="server-meta">
        Players online: <span id="server-player-count">—</span>
      </div>
    </div>

    <!-- Bet Amount -->
    <div class="field-group" style="margin-top: 20px;">
      <span class="field-label">Select Bet Amount</span>
      <select id="bet-amount">
        <option value="1">1$</option>
        <option value="5">5$</option>
        <option value="10">10$</option>
        <option value="20">20$</option>
        <option value="50">50$</option>
        <option value="100">100$</option>
      </select>
    </div>

    <button id="start-btn"><span>Play</span></button>

    <p class="hint">Press <b>Enter</b> in the box to start</p>
    <p class="footer-text">Use your mouse to steer. Left click to boost.</p>
  </div>

  <!-- GAME CANVAS -->
  <canvas id="game"></canvas>

  <script>
    // ================== PRE-GAME / SHARED CONSTANTS ==================
    let username = "Player";
    let betAmount = 1;

    const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d");

    const serverChoiceEl = document.getElementById("server-choice");
    const serverPlayerCountEl = document.getElementById("server-player-count");

    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }
    window.addEventListener("resize", resizeCanvas);

    document.getElementById("start-btn").addEventListener("click", startGame);
    document.getElementById("username").addEventListener("keydown", (e) => {
      if (e.key === "Enter") startGame();
    });

    // World & snake constants (must match server)
    const worldWidth  = 5000;
    const worldHeight = 5000;

    const baseRadius = 14;
    const baseLength = 160;
    const lengthGainPerFood = 35;
    const lengthLossPerSecond = 60;

    const normalSpeed = 260;
    const boostSpeed  = 420;
    const turnRate    = 7;
    const maxDt       = 0.035;

    // Radius helper usable for both local + remote snakes
    function getRadiusForLength(length) {
      const growthRate = 0.25 / 1000;
      const extraLength = Math.max(0, length - baseLength);
      const scale = 1 + extraLength * growthRate;
      return baseRadius * scale;
    }

    // Generic snake trimming
    function trimSnakeArray(points, targetLength) {
      if (!points || points.length < 2) return;

      let distSoFar = 0;
      for (let i = 1; i < points.length; i++) {
        const a = points[i - 1];
        const b = points[i];
        const dx = a.x - b.x;
        const dy = a.y - b.y;
        distSoFar += Math.hypot(dx, dy);
        if (distSoFar > targetLength) {
          points.length = i;
          break;
        }
      }
    }

    // ================== MULTIPLAYER (WEBSOCKET) ==================
    // IMPORTANT: This client now expects an authoritative server:
    // - client sends INPUT only (aim + boost)
    // - server simulates x/y/angle/length and broadcasts world snapshots

    let socket = new WebSocket("wss://snakebet-server.fly.dev");

    let socketOpen = false;
    let myId = null;

    // server time -> client perf time conversion (reduces "ahead/behind")
    let serverTimeOffset = null; // localPerfMs - serverEpochMs

    function getLocalTimeFromServerEpoch(serverEpochMs) {
      if (serverTimeOffset === null) return performance.now();
      return serverEpochMs + serverTimeOffset;
    }

    // id -> { id, name, hue, body: [{x,y},...], length, angle, samples, interp }
    const remoteSnakes = {};

    // my own authoritative snake state (so you render yourself same as others)
    const myNetSnake = {
      id: null,
      name: "Player",
      hue: Math.floor(Math.random() * 360),
      body: [],
      samples: [],
      interp: null,
      length: baseLength,
      angle: 0,
      render: null,
      _lastVel: null
    };

    socket.addEventListener("open", () => {
      socketOpen = true;
      console.log("Connected to SnakeBet server");
    });

    socket.addEventListener("close", () => {
      serverPlayerCountEl.textContent = "—";
      console.log("Disconnected from server");
      socketOpen = false;
    });

    socket.addEventListener("error", (err) => {
      console.error("WebSocket error:", err);
    });

    socket.addEventListener("message", (event) => {
      const data = JSON.parse(event.data);

      if (data.type === "welcome") {
        myId = data.id;
        myNetSnake.id = myId;
        console.log("Welcome, id =", myId);
        return;
      }

      if (data.type === "world") {
        // player count
        if (data.players && Array.isArray(data.players)) {
          serverPlayerCountEl.textContent = String(data.players.length);
        }

        // time sync: use server epoch time t to build stable local timeline
        if (typeof data.t === "number" && Number.isFinite(data.t)) {
          const estimate = performance.now() - data.t;
          if (serverTimeOffset === null) {
            serverTimeOffset = estimate;
          } else {
            // low-pass filter (smooth)
            serverTimeOffset = serverTimeOffset * 0.90 + estimate * 0.10;
          }
        }

        const sampleTime = (typeof data.t === "number" && Number.isFinite(data.t))
          ? getLocalTimeFromServerEpoch(data.t)
          : performance.now();

        const seenIds = new Set();

        for (const p of data.players) {
          if (!p || typeof p.id !== "string") continue;

          seenIds.add(p.id);

          const isMe = (myId !== null && p.id === myId);

          // Pull out safe values
          const px = (typeof p.x === "number" && Number.isFinite(p.x)) ? p.x : 0;
          const py = (typeof p.y === "number" && Number.isFinite(p.y)) ? p.y : 0;

          const pAngle = (typeof p.angle === "number" && Number.isFinite(p.angle)) ? p.angle : 0;
          const pLen   = (typeof p.length === "number" && Number.isFinite(p.length)) ? p.length : baseLength;

          if (isMe) {
            // update "myNetSnake"
            myNetSnake.name = p.name || myNetSnake.name;
            if (typeof p.hue === "number" && Number.isFinite(p.hue)) myNetSnake.hue = p.hue;

            myNetSnake.samples.push({
              time: sampleTime,
              x: px,
              y: py,
              angle: pAngle,
              length: pLen
            });

            myNetSnake.angle = pAngle;
            myNetSnake.length = pLen;

            if (myNetSnake.samples.length > 80) {
              myNetSnake.samples.shift();
            }

          } else {
            // update a remote snake
            let s = remoteSnakes[p.id];
            if (!s) {
              s = remoteSnakes[p.id] = {
                id: p.id,
                name: p.name || "Player",
                hue: typeof p.hue === "number" ? p.hue : Math.floor(Math.random() * 360),
                body: [],
                samples: [],
                interp: null,
                length: pLen,
                angle: pAngle,
                render: null,
                _lastVel: null
              };
            }

            s.name = p.name || s.name;
            if (typeof p.hue === "number" && Number.isFinite(p.hue)) s.hue = p.hue;

            s.samples.push({
              time: sampleTime,
              x: px,
              y: py,
              angle: pAngle,
              length: pLen
            });

            s.angle = pAngle;
            s.length = pLen;

            if (s.samples.length > 80) {
              s.samples.shift();
            }
          }
        }

        // Remove snakes not present in this snapshot
        for (const id in remoteSnakes) {
          if (!seenIds.has(id)) {
            delete remoteSnakes[id];
          }
        }

        return;
      }
    });

    function sendJoin() {
      if (!socketOpen) return;
      socket.send(JSON.stringify({
        type: "join",
        name: username,
        hue: snakeHue
      }));
    }

    // NEW: send INPUT (authoritative server sim)
    let inputSeq = 0;

    function sendInput(aimAngle, boost) {
      if (!socketOpen) return;
      socket.send(JSON.stringify({
        type: "input",
        seq: ++inputSeq,
        aim: aimAngle,
        boost: !!boost
      }));
    }

    // ================== SNAKE GAME STATE ==================

    let snakeHue = Math.floor(Math.random() * 360);

    // NOTE:
    // - In authoritative mode, snakeLength / snake[] / lastAngle are driven by server snapshots
    // - We keep the variables so the rest of your drawing code stays similar

    let snakeLength = baseLength;
    let snake = [];
    let foods = [];

    let mouse = { x: 0, y: 0 };
    let boosting = false;
    let lastAngle = 0;
    let lastTime  = null;

    let camX = 0;
    let camY = 0;

    // ---- Zoom settings ----
    let zoom = 1;
    const minZoom = 0.6;
    const maxZoom = 2.0;

    function getCurrentRadius() {
      return getRadiusForLength(snakeLength);
    }

    // ================== START GAME ==================
    let hasStarted = false;

    function startGame() {
      if (hasStarted) return;
      hasStarted = true;

      const input = document.getElementById("username");
      const name = input.value.trim();
      if (name !== "") username = name;

      const betSelect = document.getElementById("bet-amount");
      betAmount = parseInt(betSelect.value, 10) || 1;

      document.body.classList.remove("start-screen");
      document.body.classList.add("playing");

      resizeCanvas();
      respawn();
      resetFood();
      lastTime = null;

      if (socketOpen) {
        sendJoin();
      } else {
        const joinOnOpen = () => {
          socket.removeEventListener("open", joinOnOpen);
          sendJoin();
        };
        socket.addEventListener("open", joinOnOpen);
      }

      requestAnimationFrame(gameLoop);
    }

    // ================== INIT / RESPAWN / FOOD ==================
    function respawn() {
      const x = worldWidth / 2;
      const y = worldHeight / 2;

      // placeholder until server snapshots arrive
      snake = [{ x, y }];
      snakeLength = baseLength;
      boosting = false;
      lastAngle = 0;
      lastTime  = null;

      camX = x;
      camY = y;

      mouse.x = canvas.width / 2;
      mouse.y = canvas.height / 2;
    }

    function resetFood() {
      foods = [];
      for (let i = 0; i < 200; i++) spawnFood();
    }

    function spawnFood() {
      foods.push({
        x: Math.random() * worldWidth,
        y: Math.random() * worldHeight,
        radius: 4 + Math.random() * 3,
        color: `hsl(${Math.random() * 360}, 90%, 60%)`
      });
    }

    // ================== INPUT ==================
    canvas.addEventListener("mousemove", (e) => {
      const rect = canvas.getBoundingClientRect();
      mouse.x = e.clientX - rect.left;
      mouse.y = e.clientY - rect.top;
    });

    canvas.addEventListener("mousedown", (e) => {
      if (e.button === 0) boosting = true;
    });

    canvas.addEventListener("mouseup", (e) => {
      if (e.button === 0) boosting = false;
    });

    canvas.addEventListener("mouseleave", () => {
      boosting = false;
    });

    canvas.addEventListener(
      "wheel",
      (e) => {
        e.preventDefault();
        const factor = 1.08;

        if (e.deltaY < 0) zoom *= factor;
        else zoom /= factor;

        if (zoom < minZoom) zoom = minZoom;
        if (zoom > maxZoom) zoom = maxZoom;
      },
      { passive: false }
    );

    // ================== UTILS ==================
    function shortestAngleDiff(a, b) {
      let diff = (b - a) % (Math.PI * 2);
      if (diff > Math.PI) diff -= Math.PI * 2;
      if (diff < -Math.PI) diff += Math.PI * 2;
      return diff;
    }

    function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }

    // Unity-style SmoothDamp (but simplified)
    function smoothDamp(current, target, currentVelocityObj, smoothTime, dt) {
      const dtSafe = Math.max(1e-5, dt);
      smoothTime = Math.max(0.0001, smoothTime);
      const omega = 2 / smoothTime;

      const x = omega * dtSafe;
      const exp = 1 / (1 + x + 0.48 * x * x + 0.235 * x * x * x);

      let change = current - target;
      const originalTo = target;

      const maxChange = 999999;
      change = clamp(change, -maxChange, maxChange);
      target = current - change;

      let temp = (currentVelocityObj.v + omega * change) * dtSafe;
      currentVelocityObj.v = (currentVelocityObj.v - omega * temp) * exp;

      let output = target + (change + temp) * exp;

      if ((originalTo - current > 0) === (output > originalTo)) {
        output = originalTo;
        currentVelocityObj.v = 0;
      }

      return output;
    }

    function smoothDampAngle(current, target, velObj, smoothTime, dt) {
      const diff = shortestAngleDiff(current, target);
      return smoothDamp(current, current + diff, velObj, smoothTime, dt);
    }

    // ================== INTERPOLATION / RENDER STATE ==================
    // Render delay (ms): everyone (including YOU) gets rendered at the same delayed time,
    // which fixes the "I’m on top of him but I’m ahead on his screen" issue.
    const INTERP_DELAY_MS = 160;

    function updateOneSnakeFromSamples(s, dt) {
      const now = performance.now();
      const renderTime = now - INTERP_DELAY_MS;

      // tuning knobs
      const posSmoothTime = 0.11;
      const angSmoothTime = 0.13;
      const lenSmoothTime = 0.16;
      const segmentSpacing = 2.5;
      const maxExtrapMs = 120;

      const arr = s.samples;
      if (!arr || arr.length === 0) return;

      // Drop old samples until [0] and [1] bracket renderTime
      while (arr.length >= 2 && arr[1].time <= renderTime) arr.shift();

      const a = arr[0];
      const b = arr[1]; // may be undefined

      // Estimate target by interpolation, or short bounded extrapolation if b missing
      let tx = a.x, ty = a.y, tAngle = a.angle, tLen = a.length;

      if (b) {
        const span = (b.time - a.time) || 1;
        const t = clamp((renderTime - a.time) / span, 0, 1);

        tx = a.x + (b.x - a.x) * t;
        ty = a.y + (b.y - a.y) * t;

        const baseAngle = a.angle;
        const diff = shortestAngleDiff(baseAngle, b.angle);
        tAngle = baseAngle + diff * t;

        tLen = a.length + (b.length - a.length) * t;
      } else {
        // only one sample: tiny bounded extrapolation using last vel
        const extra = clamp(renderTime - a.time, 0, maxExtrapMs);
        if (s._lastVel) {
          tx = a.x + s._lastVel.vx * (extra / 1000);
          ty = a.y + s._lastVel.vy * (extra / 1000);
        }
        tAngle = a.angle;
        tLen = a.length;
      }

      // Create render state (smoothed) if missing
      if (!s.render) {
        s.render = {
          x: tx, y: ty, angle: tAngle, length: tLen,
          vx: { v: 0 }, vy: { v: 0 }, vang: { v: 0 }, vlen: { v: 0 }
        };
      }

      // Smooth toward target
      s.render.x = smoothDamp(s.render.x, tx, s.render.vx, posSmoothTime, dt);
      s.render.y = smoothDamp(s.render.y, ty, s.render.vy, posSmoothTime, dt);
      s.render.angle = smoothDampAngle(s.render.angle, tAngle, s.render.vang, angSmoothTime, dt);
      s.render.length = smoothDamp(s.render.length, tLen, s.render.vlen, lenSmoothTime, dt);

      // Store velocity estimate
      if (b) {
        const dtMs = Math.max(1, (b.time - a.time));
        s._lastVel = {
          vx: (b.x - a.x) / (dtMs / 1000),
          vy: (b.y - a.y) / (dtMs / 1000)
        };
      }

      // Update public interp for drawing
      s.interp = {
        x: s.render.x,
        y: s.render.y,
        angle: s.render.angle,
        length: s.render.length
      };

      // Build body from smoothed head path
      if (!s.body || s.body.length === 0) {
        s.body = [{ x: s.render.x, y: s.render.y }];
      } else {
        const head = s.body[0];
        const dx = s.render.x - head.x;
        const dy = s.render.y - head.y;
        const dist = Math.hypot(dx, dy);

        if (dist >= segmentSpacing) {
          s.body.unshift({ x: s.render.x, y: s.render.y });
        } else {
          head.x = s.render.x;
          head.y = s.render.y;
        }
      }

      trimSnakeArray(s.body, s.render.length);
    }

    function updateRemoteSnakes(dt) {
      for (const id in remoteSnakes) {
        const s = remoteSnakes[id];
        updateOneSnakeFromSamples(s, dt);
      }
    }

    function updateMyNetSnake(dt) {
      updateOneSnakeFromSamples(myNetSnake, dt);

      // push my authoritative render state into your existing variables
      if (myNetSnake.interp && myNetSnake.body && myNetSnake.body.length) {
        snake = myNetSnake.body;
        snakeLength = myNetSnake.interp.length;
        snakeHue = myNetSnake.hue;
        lastAngle = myNetSnake.interp.angle;
      }
    }

    function worldToScreen(wx, wy) {
      return {
        x: (wx - camX) * zoom + canvas.width / 2,
        y: (wy - camY) * zoom + canvas.height / 2
      };
    }

    // ================== MAIN LOOP ==================
    function gameLoop(timestamp) {
      if (!lastTime) lastTime = timestamp;

      let dt = (timestamp - lastTime) / 1000;
      lastTime = timestamp;

      if (dt <= 0) dt = 1 / 60;
      if (dt > maxDt) dt = maxDt;

      update(dt);
      draw();

      requestAnimationFrame(gameLoop);
    }

    // ================== UPDATE ==================
    // In authoritative mode:
    // - We DO NOT send x/y to the server
    // - We compute aimAngle (from mouse) + boost and send "input"
    // - We render ourselves from server snapshots at the same interpolation delay as others

    let inputSendAccum = 0;
    const INPUT_SEND_HZ = 30;

    function update(dt) {
      // camera follows authoritative snake, if present
      if (snake && snake.length) {
        camX = snake[0].x;
        camY = snake[0].y;
      }

      const centerX = canvas.width / 2;
      const centerY = canvas.height / 2;

      const mx = mouse.x - centerX;
      const my = mouse.y - centerY;
      const distMouse = Math.hypot(mx, my);

      const aimDeadZone = 6;
      let aimAngle = lastAngle;
      if (distMouse > aimDeadZone) {
        aimAngle = Math.atan2(my, mx);
      }

      // send inputs at a steady rate (avoids packet spam + jitter)
      inputSendAccum += dt;
      const step = 1 / INPUT_SEND_HZ;

      while (inputSendAccum >= step) {
        inputSendAccum -= step;
        sendInput(aimAngle, boosting);
      }

      // smooth/interp both self + remote snakes
      updateMyNetSnake(dt);
      updateRemoteSnakes(dt);

      // camera follow (after interpolation updates)
      if (snake && snake.length) {
        camX = snake[0].x;
        camY = snake[0].y;
      }
    }

    // ================== DRAWING ==================
    function drawBackground() {
      const centerX = canvas.width / 2;
      const centerY = canvas.height / 2;

      const grd = ctx.createRadialGradient(
        centerX, centerY, 40,
        centerX, centerY, Math.max(canvas.width, canvas.height)
      );

      const innerColor = (boosting && snakeLength > baseLength + 1) ? "#333333" : "#222222";

      grd.addColorStop(0, innerColor);
      grd.addColorStop(1, "#050505");

      ctx.fillStyle = grd;
      ctx.fillRect(0, 0, canvas.width, canvas.height);
    }

    function drawWorldBorder() {
      const topLeft = worldToScreen(0, 0);
      const w = worldWidth * zoom;
      const h = worldHeight * zoom;

      ctx.save();
      ctx.lineWidth = 4;
      ctx.strokeStyle = "red";
      ctx.strokeRect(topLeft.x, topLeft.y, w, h);
      ctx.restore();
    }

    function drawFood() {
      // NOTE: food is still local visuals here.
      // If you want food authoritative, it must be simulated server-side too.
      for (const f of foods) {
        const p = worldToScreen(f.x, f.y);
        if (p.x < -40 || p.x > canvas.width + 40 || p.y < -40 || p.y > canvas.height + 40) continue;

        ctx.beginPath();
        ctx.arc(p.x, p.y, f.radius * zoom, 0, Math.PI * 2);
        ctx.fillStyle = f.color;
        ctx.fill();
      }
    }

    function drawSnakeBodyGeneric(body, length, hue) {
      if (!body || body.length < 2) return;

      const currentRadius = getRadiusForLength(length);
      const tailIndex = body.length - 1;
      const tail = body[tailIndex];
      const head = body[0];

      const tailScr = worldToScreen(tail.x, tail.y);
      const headScr = worldToScreen(head.x, head.y);

      ctx.save();
      ctx.lineJoin = "round";
      ctx.lineCap = "round";
      ctx.beginPath();
      ctx.moveTo(tailScr.x, tailScr.y);
      for (let i = tailIndex - 1; i >= 0; i--) {
        const p = worldToScreen(body[i].x, body[i].y);
        ctx.lineTo(p.x, p.y);
      }

      ctx.lineWidth = currentRadius * 2 * zoom;

      const gradient = ctx.createLinearGradient(tailScr.x, tailScr.y, headScr.x, headScr.y);
      gradient.addColorStop(0, `hsl(${hue}, 75%, 35%)`);
      gradient.addColorStop(1, `hsl(${hue}, 85%, 60%)`);
      ctx.strokeStyle = gradient;
      ctx.stroke();
      ctx.restore();
    }

    function drawSnakeHeadAndEyesGeneric(head, length, hue, angle) {
      if (!head || !Number.isFinite(head.x) || !Number.isFinite(head.y)) return;
      if (!Number.isFinite(angle)) angle = 0;

      const currentRadius = getRadiusForLength(length);

      const headRadiusWorld = currentRadius * 1.2;
      const eyeForward = headRadiusWorld * 0.4;
      const eyeSide    = headRadiusWorld * 0.55;
      const eyeRadiusWorld  = headRadiusWorld * 0.38;
      const pupilRadiusWorld = eyeRadiusWorld * 0.5;

      const h = worldToScreen(head.x, head.y);

      ctx.beginPath();
      ctx.arc(h.x, h.y, headRadiusWorld * zoom, 0, Math.PI * 2);
      ctx.fillStyle = `hsl(${hue}, 85%, 65%)`;
      ctx.fill();
      ctx.lineWidth = 3 * zoom;
      ctx.strokeStyle = "#000";
      ctx.stroke();

      for (const side of [-1, 1]) {
        const exWorld =
          head.x +
          Math.cos(angle) * eyeForward +
          Math.cos(angle + side * Math.PI / 2) * eyeSide * 0.6;

        const eyWorld =
          head.y +
          Math.sin(angle) * eyeForward +
          Math.sin(angle + side * Math.PI / 2) * eyeSide * 0.6;

        const e = worldToScreen(exWorld, eyWorld);

        ctx.beginPath();
        ctx.arc(e.x, e.y, eyeRadiusWorld * zoom, 0, Math.PI * 2);
        ctx.fillStyle = "#ffffff";
        ctx.fill();
        ctx.lineWidth = 2 * zoom;
        ctx.strokeStyle = "#000000";
        ctx.stroke();

        const pxWorld =
          exWorld + Math.cos(angle) * eyeRadiusWorld * 0.4;
        const pyWorld =
          eyWorld + Math.sin(angle) * eyeRadiusWorld * 0.4;

        const p = worldToScreen(pxWorld, pyWorld);

        ctx.beginPath();
        ctx.arc(p.x, p.y, pupilRadiusWorld * zoom, 0, Math.PI * 2);
        ctx.fillStyle = "#000000";
        ctx.fill();
      }
    }

    function drawMySnake() {
      if (!snake || !snake.length) return;
      drawSnakeBodyGeneric(snake, snakeLength, snakeHue);
      const head = snake[0];
      drawSnakeHeadAndEyesGeneric(head, snakeLength, snakeHue, lastAngle);
    }

    function drawRemoteSnakes() {
      for (const id in remoteSnakes) {
        const s = remoteSnakes[id];
        if (!s.body || !s.body.length) continue;

        const interp = s.interp;
        const length = interp ? interp.length : s.length;
        const angle  = interp ? interp.angle  : s.angle;

        drawSnakeBodyGeneric(s.body, length, s.hue);

        const headPos = interp ? { x: interp.x, y: interp.y } : s.body[0];

        drawSnakeHeadAndEyesGeneric(headPos, length, s.hue, angle);

        const headScr = worldToScreen(headPos.x, headPos.y);
        const radius = getRadiusForLength(length) * zoom * 1.4;

        ctx.save();
        ctx.fillStyle = "white";
        ctx.font = "14px Arial";
        ctx.textAlign = "center";
        ctx.fillText(s.name || "Player", headScr.x, headScr.y - radius - 6);
        ctx.restore();
      }
    }

    function drawDirectionIndicator() {
      if (!snake || !snake.length) return;

      const head = snake[0];
      const currentRadius = getCurrentRadius();

      const distWorld = currentRadius * 3;
      const sizeWorld = currentRadius * 0.45;

      const dotXWorld = head.x + Math.cos(lastAngle) * distWorld;
      const dotYWorld = head.y + Math.sin(lastAngle) * distWorld;

      const d = worldToScreen(dotXWorld, dotYWorld);

      ctx.beginPath();
      ctx.arc(d.x, d.y, sizeWorld * zoom, 0, Math.PI * 2);
      ctx.lineWidth = 2 * zoom;
      ctx.strokeStyle = "rgba(255,255,255,0.8)";
      ctx.stroke();
    }

    function drawHUD() {
      ctx.fillStyle = "rgba(255,255,255,0.9)";
      ctx.font = "16px Arial";
      ctx.textAlign = "left";
      ctx.fillText(`Player: ${username}`, 20, 30);
      ctx.fillText(`Bet: ${betAmount}$`, 20, 50);
      ctx.fillText("Move the mouse around your snake to steer (Slither-style).", 20, 70);
      ctx.fillText("Hold LEFT MOUSE to BOOST (server-authoritative).", 20, 90);
      ctx.fillText(`Length: ${Math.round(snakeLength)}`, 20, 110);
      ctx.fillText(`Zoom: ${zoom.toFixed(2)}x`, 20, 130);

      if (boosting && snakeLength > baseLength + 1) {
        ctx.fillStyle = "rgba(255,200,200,0.95)";
        ctx.fillText("BOOSTING!", 20, 150);
      }

      ctx.textAlign = "right";
      ctx.fillStyle = "rgba(255,255,255,0.7)";
      ctx.fillText(
        "Mouse wheel = zoom. Red box = world border. Rendering uses server snapshots.",
        canvas.width - 20,
        30
      );
    }

    function draw() {
      drawBackground();
      drawWorldBorder();
      drawFood();
      drawRemoteSnakes();
      drawMySnake();
      drawDirectionIndicator();
      drawHUD();
    }
  </script>
</body>
</html>
